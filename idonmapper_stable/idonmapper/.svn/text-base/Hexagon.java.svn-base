package idonmapper;

import java.awt.*;
import javax.swing.*;
import java.awt.geom.*;
import java.awt.event.*;
import java.util.*;

/*
 * Represents a Hexagon shape.
 */
public class Hexagon
{
    private GeneralPath path;
    private AffineTransform aff;
    private double sideLength, hexOffset, xPos, yPos;
    private Shape hexShape = null;
    private boolean shapeCreated = false;

    /*
     * Hexagon
     */
    public Hexagon(double size, double xPos, double yPos)
    {
        checkArgs(size, xPos, yPos);
        sideLength = size;
        setPosition(xPos, yPos);
    }


    /*
     * Checks the size, xPos and yPos arguments
     * for non-positive values.
     */
    private void checkArgs(double... numbers)
    {
        if(containsNegativeOrZero(numbers))
        {
            throw new IllegalArgumentException("Hexagon constructor received negative " +
                "number : " + numbers);
        }
    }

    private boolean containsNegativeOrZero(double... numbers)
    {
        for(double n : numbers)
        {
            if(n < 0 || n == 0)
            {
                return true;
            }
        }
        return false;
    }

    /*
     * Sets the Hexagon's shape according to the arguments given
     * to the constructor.
     */
    private void setUp()
    {
        hexOffset = sideLength * Math.sqrt(3);
        path = createPath();
        path.closePath();
        scaleRotateAndMove();
        createShape();
    }

    /*
     * Creates the Hexagon's GeneralPath object based on its given
     * coordinates.
     */
    private GeneralPath createPath()
    {
        GeneralPath path = new GeneralPath();
        path.setWindingRule(GeneralPath.WIND_EVEN_ODD);
        path.moveTo(1, 0);
        int n = 1;

        while(n < 6)
        {
            path.lineTo(Math.cos(n * Math.PI/3),
                        Math.sin(n * Math.PI/3));
            ++n;
        }
        return path;
    }


    public double getHexOffset()
    {
        return hexOffset;
    }

    /*
     * Associates a pair of HexGrid coordinates with this hexagon.
     */
    /*public void setCoords(int x, int y)
    {
        coord = new Coord(x, y);
    }*/


    /*
     * Alter the position of the Hexagon, then create its
     * new geometry.
     */
    public void setPosition(double xPos, double yPos)
    {
        this.xPos = xPos;
        this.yPos = yPos;
        setUp();
    }

	/*
	 * Returns the Hexagons horizontal hexgrid coordinate 
	 */
    public double getXPos()
    {
        return xPos;
    }
    /*
	 * Returns the Hexagons vertical hexgrid coordinate 
	 */
    public double getYPos()
    {
        return yPos;
    }

    /*
     * Scales up the path to the desired demension and rotates
     * to the 'pointing up' orientation
     */
    private void scaleRotateAndMove()
    {
        aff = new AffineTransform();
        aff.translate(xPos, yPos);
        aff.rotate(Math.PI / 6);
        aff.scale(sideLength, sideLength);
    }
    /**
	 * Returns the Hexagon's GeneralPath object.
	 */ 
    public GeneralPath getPath()
    {
		if(path == null)
		{
			System.out.println("Hexagon.getPath() Argh! GeneralPath "
				+ "object not been created ");
			
		}
        return path;
    }

    private void createShape()
    {
        hexShape = aff.createTransformedShape(path);
        shapeCreated = true;
    }

	/**
	 * Returns the Hexagon's side (i.e. vertex) length.
	 */ 
    public double getSideLength()
    {
        return sideLength;
    }

    /**
     * Returns the Hexagon's Shape object. createShape  
     */
    public Shape getShape()
    {
        if(shapeCreated == false)
        {
            createShape();
        }
        return hexShape;
    }

    /*
     * Draws the Hexagon (i.e. onto a HexPanel).
     */
    public void draw(Graphics2D g)
    {
        g.draw(getShape());
    }

    private boolean containsPoint(MouseEvent e)
    {
        if(this.getShape().contains(e.getPoint()))
        {
            return true;
        }
        return false;
    }


    public boolean buttonPressedInside(MouseEvent e)
    {
        if(containsPoint(e))
        {
            return true;
        }
        return false;
    }


    public String toString()
    {
        return "Hexagon";
    }

    /**
     * Returns true if the Hexagon's hexShape overlaps
     * @rectangle.
     */
    public boolean intersects(Rectangle rectangle)
    {
        if(this.getShape().getBounds().intersects(rectangle))
        {
            return true;
        }
        return false;

    }

}



