package idonmapper;

import java.awt.*;
import javax.swing.*;
import java.awt.geom.*;
import java.awt.event.*;
import javax.swing.event.*;
import java.util.*;

/* 
 * HexPanel - coordinate-based Hexagonal grid. Idons are associated with 
 * Coord objects.
 */
public class HexPanel extends JPanel 
{
    private ArrayList<Hexagon> cellList;
    private HashMap<Coord, Hexagon> coordMap;
    private HashMap<Coord, Idon> idonMap;
    private ArrayList<Coord> coordList;
    private HashSet<Coord> selectedCoords;
    private double hexSize, r, hexDist;
    private int rows = 0, columns = 0;
    
    /*	 
     *  These constantsrepresent the maximum allowable sizes, 
     *  respectively, of:
     *  
     *  MAX_HEX_SIZE - the sideLength (vertex size) of the Hexagons 
     * 					on the grid;
     * 	MAX_COLUMNS	 - the maximum allowable amount
     *  			   of columns on the grid;
     * 	MAX_ROWS	-the maximum allowable amount of rows on the grid;
     *   
     */  
    
    public static final double MAX_HEX_SIZE = 400.0;
    public static final int MAX_COLUMNS = 200;
    public static final int MAX_ROWS = 200;
    
    /*
     * HexPanel()
     * Create a HexPanel with the specified number of rows
     * and columns. 
     */
    public HexPanel(double hexSize, int rows, int columns)
    {
        super(null, false);
        checkArgs(hexSize, rows, columns);
        this.hexSize = hexSize;    
        
        // distance between the center of 2 hex cells
        hexDist = hexSize * Math.sqrt(3);
        r = Math.cos(30) * hexSize;
        setGridDimensions(rows, columns);
        setBackground(Color.white);
        selectedCoords = new HashSet<Coord>();
    }
    
    private void checkArgs(double hexSize, int rows, int columns)
    {
        if(hexSize > MAX_HEX_SIZE || rows > MAX_ROWS || columns > MAX_COLUMNS)
        {
            throw new IllegalStateException("HexPanel received illegal variable(s): \n"
                + hexSize + ", " + rows + ", " + columns);
        }
    }
    
    /*
     * Sets the number of rows and columns of this
     * HexPanel. 
     */
    protected void setGridDimensions(int rows, int columns)
    {
        this.rows = rows;
        this.columns = columns;
        createHexagonCells();
        setPreferredSize(calculateMinimumSize());
    }       
    
    
    /** 
     * Returns an unoccupied cell inside (or near to) the 
     * the JScrollPane's viewport
     */
    public Coord getVisibleUnoccupiedCell()
    {
//        Controller.getHexScroller()
        return null;
    }
    
    
    /** 
     * Returns the coordinates of the first unoccupied cell on the grid.
     */
    public Coord getUnoccupiedCell()
    {
        for(Coord c : coordList)
        {
            if(!cellContainsIdon(c))
            {
                return c;
            }
        }
        throw new IllegalStateException("No empty cells left!");
    }
    
    /**
     * Return the Hexagon at the specified Coordinate.
     */
    protected Hexagon getHexagonFromCoord(Coord c)
    {
        try
        {
            Hexagon h = coordMap.get(c);
            return h;
        }
        catch(NullPointerException e)
        {
            System.out.println("getHexagonFromCoord returned null!");
            return null;
        }
    }
    
    private void createHexagonCells()
    {
        cellList = new ArrayList<Hexagon>(rows*columns);
        coordMap = new HashMap<Coord, Hexagon>();
        idonMap = new HashMap<Coord, Idon>();
        coordList = new ArrayList<Coord>(rows*columns);
        
        int incrOdd = 1;
        int incrEven = 3;
        
        for(int col = 1; col <= columns; ++col)
        {
            if(isOdd(col))
            {
                createRow(col, hexDist/2, hexSize*incrOdd);
                incrOdd += 3;
            }
            else
            {
                createRow(col, hexDist, ((hexSize/2) * (col + incrEven)));
                incrEven += 4;
            }
        }
    }
    
    /*
     * Set and return a @Dimension containing the minimum size the panel
     * must be in order to display all of the hex cells, according to the
     * rows and columns.
     */
    public Dimension calculateMinimumSize()
    {
        double x, y = 0;
        int padding = 10;
        x = (hexDist * rows) + (hexDist/2);
        y = (hexDist * columns);
        
        y -= (hexDist * (columns / 8));
        // ^ very sketchy Maths...
        
        Dimension min = new Dimension((int)x + padding, (int)y);// + padding);
        return min;
    }
    
    /*
     * Create a row of hexagonal cells that will later be
     * drawn onto the HexPanel. 
     * 
     * Deals with odd and even rows separately
     */
    private void createRow(int column, double xPos, double yPos)
    {
        int incr = 1;
        
        for(int x = 1; x <= rows; ++x)
        {
            Hexagon h = new Hexagon(hexSize, (xPos * incr), yPos);
            Coord coord = new Coord(x, column);
            coordMap.put(coord, h);
            coordList.add(coord);
            cellList.add(h);
            if(isOdd(column))
            {
                incr += 2;
            }
            else
            {       
                ++incr;
            }
        }
    }
    
    private boolean isOdd(int n)
    {
        if(n % 2 != 0 && n >= 0)
        {
            return true;
        }
        return false;
    }
    
    private boolean isButton(MouseEvent e, int n)
    {
        if(e.getButton() == n)
        {
            return true;
        }
        return false;
    }
    
    /**
     * Returns a mapping of the Idons surrounding @this one
     * and their Coords.
     **/
    protected HashMap<Direction, Idon> getNeighbours(Idon idon)
    {
        // get this Idon's coordinate on the HexPanel
        Coord current = idon.getCoord();
        
        if(current == null)
        {
            throw new IllegalStateException("could not find this Idon on the HexPanel");
        }
        
        //System.out.println("getNeighbours -> checking " + this 
          //  + " [at Coord " + current + "] for neighbours");
        
        HashMap<Direction, Idon> map = new HashMap<Direction, Idon>();
        
        // check adjacent cell to the idon in each direction 
        for(Direction d : Direction.values())
        {
            Coord c = Direction.directionToCoord(current, d);
            
            if(containsCoord(c))
            {
                Idon i = getIdonFromCoord(c);
                
                if(i != null)
                {
                    map.put(d, i);
                }
                
            }            
        }
        return map;
    }
    
    /**
     * Recursively adds all the idons linked to idon @i on the grid.
     * to the @linked HashSet.
     */
    protected void getAllLinked(Idon i, HashSet<Idon> linked)
    {
        if(linked.contains(i))
        {
            return;
        }
        
        linked.add(i);
        
        for(Idon n : getNeighbours(i).values())
        {
            getAllLinked(n, linked);
        }
        return;
    }
    
    /**
     * Returns a HashSet of all the sets of linked 
     * idons to be found on the HexPanel.
     */
    protected HashSet<HashSet<Idon>> collectAllLinkedSets()
    {
        HashSet<HashSet<Idon>> allSet = new HashSet<HashSet<Idon>>();
        
        HashSet<Idon> currentLink = new HashSet<Idon>();

        for(Coord c : idonMap.keySet())
        {
            Idon i = idonMap.get(c);
            
            // check if idon 'i' is in any of the linked sets
            if(!collectionsContainsIdon(allSet, i))
            {
                // if none of the sets contain this idon,
                // add all its connected Idons to the allSet
                // collection.
                    
                currentLink = new HashSet<Idon>();
                getAllLinked(i, currentLink);
                allSet.add(currentLink);
            }
            
        }
        return allSet;
    }
    
    protected void printOutAllLinkedSets(HashSet<HashSet<Idon>> all)
    {
        for(HashSet<Idon> hs : all)
        {
            System.out.print("LINKED SET:  ");
            printOutHashSet(hs);
        }
    }
    
    /* 
     * Returns true if the specified Idon is within any of the collections inside 
     * collection @all.
     */
    private boolean collectionsContainsIdon (HashSet<HashSet<Idon>> all, Idon idon)
    {
        if(all.isEmpty())
        {
            return false;
        }
        
        Iterator<HashSet<Idon>> iter = all.iterator();
        
        while(iter.hasNext())
        {
            HashSet<Idon> hm = iter.next();
            if(hm.contains(idon))
            {
                return true;
            }
        }
        
        return false;
    }
    
    public void printNeighbours(Idon i)
    {
        HashMap<Direction, Idon> neighbours = getNeighbours(i);
        System.out.println(i + " neighbours:");
        
        for(Direction d : neighbours.keySet())
        {
            Idon idon = neighbours.get(d);
            System.out.println("\tdirection " + d + ": " + idon);
        }
    }
    
    protected Idon getIdonFromCoord(Coord c)
    {
        if(idonMap == null)
        {
            throw new IllegalStateException("idonMap not created!");
        }
        
        for(Coord coord : idonMap.keySet())
        {
            if(c.equals(coord))
            {
                Idon i = idonMap.get(coord);
                return i;
            }
        }
        
        return null;
    }
    
    protected boolean containsCoord(Coord c)
    {
        for(Coord coord : coordMap.keySet())
        {
            if(coord.equals(c))
            {
                return true;
            }
        }
        return false;
    }
    
    private Hexagon getCellFromMousePoint(MouseEvent e)
    {
        ListIterator<Hexagon> i = cellList.listIterator();
        while(i.hasNext())
        {
            Hexagon cell = i.next();
            if(cell.buttonPressedInside(e))
            {
                return cell;
            }
        }
        System.out.println("getCellFromMousePoint returning null");
        return null;
    }
    
    /** 
     * Return the Coord for the Idon containing the String @s.
     */
    protected Coord getCoordFromString(String s)
    {
        for(Coord c : idonMap.keySet())
        {
            if(idonMap.get(c).toString().toLowerCase().equals(s.toLowerCase()))
            {
                /*System.out.println("getCoordFromString: found " + s + " at "
                    + c);*/
                return c;   
            }
        }
        return null;
    }
    
    protected Coord getCoordFromMousePoint(MouseEvent e)
    {
        Hexagon h = getCellFromMousePoint(e);
        if(h == null)
        {
            System.out.println("getCoordFromMousePoint: "
                                + "outside of all cells!");
            return null;
        }
        for(Coord c : coordMap.keySet())
        {
            // find the coordinate mapped to 
            // hexagon 'h':
            if(coordMap.get(c).equals(h))
            {
                return c;
            }
        }
        
        return null;
    }

    /*
     * Paints the Idons and Hex cells if they intersect 
     * the scrollpane's viewport.
     */
    public void paintComponent(Graphics g)
    {
        super.paintComponent(g);
        Graphics2D g2 = setUpGraphics(g);
        paintIdons(g2);
        paintGrid(g2); 
        //printConnectedIdons();
    }
    
    /*
     * Returns a rectangle delimiting the visible area of
     * this HexPanel according to the JScrollPane's viewport.
     */
    private Rectangle visibleArea()
    {
        return Controller.getHexScroller().getViewport().getViewRect();
    }
    
    /*
     * Paints the Hexagonal grid (not the Idons) cells using the 
     * JPanel's Graphics2D object .
     *
     * For greater efficiency, Hexagon cells are drawn only if 
     * their bounding Rectangles intersect 
     * the Controller's current JViewport rectangle. 
     */
    private void paintGrid(Graphics2D g2)
    {
        for(Coord c : coordList)
        {
            if(!cellContainsIdon(c))
            {
                Hexagon h = coordMap.get(c);
                if(h.intersects(visibleArea()))
                {
                    h.draw(g2);
                }
            }
        }
    }
    
    /*
     * Paints the Idons that are visible, according to 
     * the visibleArea() Rectangle.
     */
    private void paintIdons(Graphics2D g2)
    {
        // check if the idon intersects the 
        // visibleArea Rectangle.
        
        //ArrayList<String> visibleIdons = new ArrayList<String>();
            
        for(Idon i : idonMap.values())
        {
            if(i.intersects(visibleArea()))
            {
                i.draw(g2);
                //visibleIdons.add(i.toString());
            }
        }
        
        /*System.out.println("Visible: ");
        for(String s : visibleIdons)
        {
            System.out.print(s + ", ");
        }
        System.out.println();*/
    }
    private Graphics2D setUpGraphics(Graphics g)
    {
        Graphics2D g2 = (Graphics2D)g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, 
                            RenderingHints.VALUE_ANTIALIAS_ON);
        g2.setStroke(new BasicStroke(1.5f));
        g2.setPaint(new Color(0, 0, 0)); 
        return g2;
    }
    
    /**
     * Returns true if the cell at Coord @c
     * contains an Idon.
     */
    public boolean cellContainsIdon(Coord c)
    {
        if(idonMap.containsKey(c))
        {
            return true;
        }
        return false;
    }
    
    
    
    /*
     * Associates a hexagon cell with an idon.
     */
    public void addIdon(Coord c, String s)
    {
        if(this.containsIdea(s))
        {
            System.out.println("hexPanel already contains idon " + s);
            return;
        }            
        
        Idon i = new Idon(getHexagonFromCoord(c));
        i.setIdea(s);
        idonMap.put(c, i);
        
        //System.out.println("put IdonMap : " + c + " = " + i);
        repaint();
    }
    
    
    /**
     * Returns true if the HexPanel contains an Idon
     * with the String @s.
     */
    /*
     * Treating everything as lower
     * case for simplicity....
     */
    public boolean containsIdea(String s)
    {
        s = s.toLowerCase();
            
        for(Coord c : idonMap.keySet())
        {
            if(s.equals(idonMap.get(c).getIdea().toLowerCase()))
            {
                return true;    
            }
        }
        return false;
    }
    
    public void printIdons()
    {
        System.out.println("    IDONS:");
        for(Coord c : idonMap.keySet())
        {
            System.out.println(c + "--->   " + idonMap.get(c));   
        }
    }
        
    /* 
     * Remove a hexagon:idon association
     * from the hashmap.
     */
    protected void removeIdon(Coord c)
    {
        System.out.println("removing " + idonMap.get(c) 
            + " from " + c);
        idonMap.remove(c);
        repaint();
    }
    
    private int getIdonCount()
    {
        return idonMap.size();
    }
    
    private void printOutHashSet(HashSet<?> h)
    {
        Iterator it = h.iterator();
        while(it.hasNext())
        {
            System.out.print(it.next().toString() + ", ");
        }
        System.out.println();
    }
     
    private void addIdonsToHashSet(HashSet<Idon> set, Collection<Idon> idons)
    {
        for(Idon i : idons)
        {
            set.add(i);
        }
    }
    
    
    private HashSet<Idon> findInSetList(Idon idon, ArrayList<HashSet<Idon>> setList)
    {
        for(HashSet<Idon> set : setList)
        {
            if(set.contains(idon))
            {
                return set;
            }
        }
        return null;
    }  
}
